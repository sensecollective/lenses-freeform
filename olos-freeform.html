<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../iron-selector/iron-selector.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-doc-viewer/iron-doc-viewer.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href="../paper-toolbar/paper-toolbar.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">

<link rel="import" href="../ace-widget/ace-widget.html">


<link rel="import" href="../lens-ui-dialog/lens-ui-dialog.html">
<link rel="import" href="../olos-component-list/olos-component-list.html">
<link rel="import" href="../olos-destination/olos-destination.html">
<link rel="import" href="../olos-clock/olos-clock.html">

<dom-module id="olos-freeform">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */
    [layout] {
      @apply(--layout);
    }
    [layout][horizontal] {
      @apply(--layout-horizontal);
    }
    [layout][end-justified] {
      @apply(--layout-end-justified);
    }
  </style>

  <!-- load external libraries -->
  <script src="../../Tone.js/build/Tone.js"></script>
  <script src="../p5js/p5.js"></script>
  <script src="../p5js/p5.sound.js"></script>
  <script>
      audioContext = p5.prototype.getAudioContext();
      Tone.setContext(audioContext);
  </script>


  <link rel="import" type="css" href="olos-freeform.css">
  <template>

    <style is="custom-style">
      paper-toolbar {
        /*--paper-toolbar-background: rgba(63, 81, 181, 0.67);*/
        --paper-toolbar-background: #FDF6E3;
        --paper-toolbar-color: #636363;
      }

      paper-toolbar.topnav {
        --paper-toolbar-background: #C5C5C3;
        --paper-toolbar: {
           position:fixed;
           width:100%;
           z-index:100;
         };
      }

    </style>
    <paper-toolbar class="topnav">
      <h1 style="margin-left:30px;color: #8C6E9D"> (( Olos )) </h1>
      <olos-clock style="margin-left:30px;"></olos-clock>
    </paper-toolbar>

    <div class="settings-slideout slideout right">

      <span class="slideout-handle">settings</span>
      <div class="slideout-inner">

        <paper-icon-button id="showDataBtn" class="active" icon="view-module" on-click="showDataBtn" alt="show component data">
          <span>show component input/output</span>
        </paper-icon-button>
  
       <!--
        <core-icon-button id="saveBtn" icon="save" on-click="{{showSaveDialog}}" alt="save">
        </core-icon-button>
      -->
      </div>
    </div>


    <div class="zoom-slideout slideout left">

      <span class="slideout-handle">zoom</span>
      <div class="slideout-inner">
        <div id="zoomOptions">
          <iron-icon-button id="zoomInBtn" class="" icon="add" on-click="zoomIn">
          </iron-icon-button>
          <br>
          <input is="iron-input" id="zoomRange" type="range" value="{{_zoom::input}}" min="{{_zoomMin}}" max="{{_zoomMax}}" step="{{_zoomStep}}" style="width:25px" list="zoomsettings">
          
          <datalist id="zoomsettings">
            <option>1</option>
            <option>0.8</option>
            <option>0.6</option>
          </datalist>
          <br>
          <iron-icon-button id="zoomOutBtn" icon="remove" on-click="zoomOut">
          </iron-icon-button>
        </div>
      </div>
    </div>

    <div class="component-slideout slideout right">
      <span class="slideout-handle">components</span>
      <div class="slideout-inner">
        <label class="label">Drag components into canvas:</label>
          <olos-component-list id="component_list"></olos-component-list>
      </div>
    </div>

    <!-- destination -->
    <div id="wrapper-olos-destination" class="olos-destination drop-zone output-slideout output left" on-dragend="droppedOnDestination" on-drop="droppedOnDestination" on-click="clickedOnDestination" style="z-index:1000; right:0px;">
      <olos-destination id="olos-destination" class="olos-destination" on-dragover="draggedOverContainer" 
      style="position:absolute; right:0px;"></olos-destination>
    </div>


    <!-- MODALS -->
    <lens-ui-dialog autoclosedisabled="" id="deleteDialog">
      <p>Are you sure you want to remove the selected item?</p>
      <div horizontal="" end-justified="" layout="">
        <paper-icon-button icon="clear" dismissive="" on-click="_noDelete"></paper-icon-button>
        <paper-icon-button icon="check" affirmative="" on-click="_yesDelete"></paper-icon-button>
      </paper-icon-button></div>
    </lens-ui-dialog>

    <!-- Title and Author fields + save action in dialog-->
    <lens-ui-dialog class="dialog" id="savedetails">
      <h1><paper-input label="Title of Lens" value="{{lensTitle}}"></paper-input></h1>
      <h3><paper-input label="Your Name" value="{{lensAuthor}}"></paper-input></h3>
      <paper-icon-button class="save" affirmative="" icon="check" ng-click="saveLens()" on-click="_saveLens">
      <paper-icon-button class="" dismissive="" icon="clear"></paper-icon-button> 
    </paper-icon-button></lens-ui-dialog>

    <!-- Docs Dialog -->
    <paper-dialog class="elt-dialog" id="infoDialog">
        <iframe class="docs-frame" src="[[_selElementDocPath]]">
        </iframe>
    </paper-dialog>

    <!-- Code Dialog -->
    <paper-dialog class="elt-dialog" id="codeDialog">

      <paper-toolbar>
        <span class="title float-left">{{_selElement.varName}}</span>


        <paper-icon-button class="play" title="Run Code" icon="av:play-circle-filled" on-click="updateCode"></paper-icon-button>

        <paper-dropdown-menu id="methodDropdown" label="{{_selectedMethod}}" class="dropdown-trigger float-right">

            <paper-menu selected="0" id="selector" on-iron-select="_methodChanged" class="menu dropdown-content">
            <template is="dom-repeat" as="meth" items="{{_publicMethods}}">
              <paper-item label="{{meth}}">{{meth}}</paper-item>
            </template>
          </paper-menu>
        <!-- </paper-dropdown> -->
      </paper-dropdown-menu>
    

      </paper-toolbar>

      <ace-widget id="codeEditor" theme="ace/theme/solarized_light" mode="ace/mode/javascript"></ace-widget>
    </paper-dialog>




    <!-- container -->
    <div id="container" on-mousedown="clickInContainer" on-drop="droppedInContainer" on-dragover="draggedOverContainer" on-mouseup="dragEndSVG" on-mousemove="dragSVG">

      <svg id="svg">

      </svg>



      <!-- Components and connector dots --> 

      <template is="dom-repeat" class="render-after-el" items="{{_elements}}" as="el" index-as="index">
      <!-- el is not working ?!?! -->

        <div id="{{computeWrapperId(el)}}" component-id="{{el.id}}" on-click="wrapperClicked" on-dragstart="dragStartWrapper" on-drag="dragWrapper" on-dragend="dragEndWrapper" draggable="true" class$="{{concatClassNames()}}" style$="{{computeWrapperStyles(el)}}">

          <span class="elt-top-bar">
            <label>{{el.id}}</label>
            <label class="elt-info-label" on-click="_elInfoButtonClicked"><iron-icon icon="icons:info-outline"></iron-icon></label>
            <label class="elt-src-label" on-click="_elCodeButtonClicked"><iron-icon icon="icons:code"></iron-icon></label>

            <div class="deleteEl" component_id="{{el.id}}" on-click="_deleteElementEvent">X</div>
          </span>

            <!-- Input -->
            <div class="connectors-in">
              
              <ul>
                <template is="dom-repeat" items="{{_checkForInputAttr(index)}}" as="ins">
                     
                    <li on-dragover="dragOverInArrow" on-drop="droppedOnInArrow" on-dragenter="dragEnterInArrow" on-dragleave="dragLeaveInArrow" on-click="arrowClicked" class$="{{computeClassInArrow(el, ins)}}"
                    id$="{{computeIdInArrow(el, ins)}}" >

                      <div class="inputMarker" data-tooltip$="{{computeIdInArrow(el, ins)}}">
                        <div class="delete" on-click="deleteConnection">x</div>
                        <span class="drop-zone" data-tooltip$="{{computeIdInArrow(el, ins)}}">{{ins}}</span>
                      </div>
                    </li>
                    <paper-tooltip
                      animation-delay="1"
                      manual-mode="true"
                      class$="{{computeIdInArrow(el, ins)}}"
                      position="left"
                      for="{{computeIdInArrow(el, ins)}}">
                      audio input
                    </paper-tooltip>
                </template>
              </ul>
            </div>

            <!-- Params -->
            <div class="connectors-params">
              
              <ul>
                <template is="dom-repeat" items="{{_checkForAudioParams(index)}}" as="param">
                     <li class="param-arrow" 
                        on-dragenter="dragEnterInArrow"
                        on-dragover="dragOverInArrow"
                        on-dragleave="dragLeaveInArrow"
                        on-drop="droppedOnParamArrow" 
                        class$="{{computeClassInArrow(el, param)}}"
                        id$="{{computeIdInArrow(el, param)}}"
                        data-elt$={{el.id}}
                        data-param$="{{param}}"
                        data-tooltip$="{{computeIdInArrow(el, param)}}"
                        >
                      <div class="inputMarker paramMarker" data-param$="{{param}}" data-elt$="{{el.id}}" data-tooltip$="{{computeIdInArrow(el, param)}}">
                        <!-- {{param}} -->
                        <div class="delete" on-click="deleteConnection" data-tooltip$="{{computeIdInArrow(el, param)}}"></div>
                        <span class="drop-zone" data-tooltip$="{{computeIdInArrow(el, param)}}">
                        </span>
                      </div>
                     </li>
                    <paper-tooltip
                      animation-delay="1"
                      class$="{{computeIdInArrow(el, param)}}"
                      position="left"
                      for="{{computeIdInArrow(el, param)}}">
                      {{param}}
                    </paper-tooltip>
                </template>
              </ul>
            </div>
            <!-- Output -->
            <div class="connectors-out">
              <template is="dom-if" if="{{_checkForOutputAttr(index)}}">
                <div id="{{index}}" on-drag="dragOutArrow" on-dragstart="dragOutArrowStart" on-dragend="dragOutArrowEnd" on-click="arrowClicked" draggable="true" class$="{{computeClassOutArrow(el)}}">
                  <div class="outputMarker"></div>
                </div>
              </template>
              
            </div>

            <!-- for components with settings (all non-resizables?) -->
            <template is="dom-if" if="{{!el.resizable}}">

              <iron-icon icon="settings" component-id$="{{el.id}}" on-click="toggleSetting" class="setting-btn"></iron-icon>

            </template>

            <template is="dom-if" if="{{el.resizable}}">
              <div class="resize" draggable="true" style$="{{computeResizeStyle(el)}}" on-dragstart="dragStartResize" on-drag="dragResize" on-dragend="dragResizeEnd"></div>
            </template>
          
        </div>
 
         <!--
         not working. instead move actual element alongside container.
        <template is="dom-if" if="{{computeIfResizable(el)}}">
          <iron-collapse class="settings-collapse" id="{{computeCollapseId(el)}}" opened="true" style$="{{computeCollapseStyle(el)}}">
             <content select="{{computeSelect(el)}}"></content>
          </iron-collapse>
        </template>
        -->
          

      </template>


    </div> <!-- end container -->

  </template>
</dom-module>
<script>
  Polymer({
    is: 'olos-freeform',
    properties: {
      _connections: {
        type: Array,
        value: function () {
          return [];
        }
      },
      _deleteCallback: { value: null },
      _dragArea: { value: null },
      _dragObj: {
        value: {},
        type: Object
      },
      _elements: {
        type: Array,
        observer: '_elementsChanged',
        notify: true,
        value: function () {
          return [];
        }
      },
      _highlightedConnection: { value: null },
      _hotKeys: {
        type: Object,
        value: function () {
          return {
            '18': false,
            // 18 = option
            '16': false,
            // 16 = shift
            '17': false,
            // 17 = control
            '91': false  // 91 = command
          };
        }
      },
      _makeDragArea: {
        type: Boolean,
        value: false
      },
      _outputComponents: {
        type: Array,
        value: function () {
          return [];
        }
      },
      _selElement: { 
        value: null,
        observer: '_selElementChanged',
      },
      _selElementDocPath: {
        value: null
      },
      _selectedMethod: {
        value: undefined,
      },
      _publicMethods: {
        value: [],
        type: Array
      },
      _selWrappers: {
        type: Array,
        value: function () {
          return [];
        }
      },
      _selectingElByDrag: {
        type: Boolean,
        value: false
      },
      _showDataTable: {
        type: Boolean,
        value: true
      },
      _snapX: {
        type: Number,
        value: 10
      },
      _snapY: {
        type: Number,
        value: 10
      },
      _zoom: {
        type: Number,
        value: 1,
        observer: '_zoomChanged'
      },
      _zoomMax: {
        type: Number,
        value: 1
      },
      _zoomMin: {
        type: Number,
        value: 0.6
      },
      _zoomStep: {
        type: Number,
        value: 0.2
      },
      structure: {
        value: null,
        notify: true,
       /* observer: 'scaffold'*/
      },
      _customMethods: {
        value: {},
        type: Object
      }
    },
    ready: function () {
      this.focus();
      this.tabIndex = 0;
      this.animate();

      this.destination = this.$$('olos-destination');
      this.clock = this.$$('olos-clock');


      this.id = 'olos';
      this.varName = 'olos';
      // init custom methods object for the environment
      this._initCustomMethodsObj(this);


      // for testing:
      window.olos = this;

      this.initEventListeners();

      this.initEditor();
      // if ($('div.core-overlay-backdrop.core-opened').length > 0) e.preventDefault();
      // });

      this.$.zoomRange.value = this._zoom;

      // start animation loop
      this.animate();

    },

    initEditor: function() {
      this.$.codeEditor.editor.$blockScrolling = Infinity;
    },

    initEventListeners: function() {
      var self = this;
      // not sure if this event is even being triggered? 9/16
      this.addEventListener('iron-resize', function () {
        console.log('iron resize occured');
        this._drawConnections();
      });

      var dialogs = document.getElementsByTagName('paper-dialog');

      // prevent mousewheel scrolling
      var drawLoop = 0;
      document.addEventListener('mousewheel', function(e) {
        // redraw connections
        if (drawLoop % 12 === 0) {
          self._drawConnections();
        }
        drawLoop++;

        for (var i = 0; i < dialogs.length; i++) {
          var d = dialogs[i];
          if (d.opened) {
            e.stopPropagation();
            e.preventDefault();
          }
        }
      });
    },

    addNewElToLens: function (newElName, _left, _top) {
      var newEl = document.createElement(newElName);
      var top = _top / this._zoom;
      var left = _left / this._zoom;
      this.$.component_list.checkAndImport(newEl, function () {
  
        //TODO redundant code (_processNewElement)
        var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());
        var resizable = info.resizable || info.category === 'visualize';

        if(resizable) {
          newEl.style.width = '250px';
          newEl.style.height = '200px';
          newEl.classList.add('lens-component-resizable');

        }
        newEl.style.top = (resizable? top+5 : top+45)+'px';

        newEl.style.left = left+'px';
        newEl.style.opacity = resizable ? 1 : 0;
        // newEl.style.display = 'none';
        newEl.style.height = '0%';
        //newEl.style.top = '0px';
        //newEl.style.left = '0px';
        //newEl.style.transform = 'translate('+left+'px, '+(top+45)+'px)';
        newEl.style.position = 'absolute';

        newEl.classList.add('lens-component');

        Polymer.dom(this.$.container).appendChild(newEl);
        this._processNewElement(newEl, top, left);
        this._renderContainerTemplate();
      }.bind(this));
    },
    _renderContainerTemplate: function() {
      if(!this._containerTemplates)
      this._containerTemplates = Polymer.dom(this.root).querySelectorAll('.render-after-el');
      [].forEach.call(this._containerTemplates, function(item) {
        // console.log('rendering', item);
        item.render();
      });
    },
    _processNewElement: function (newEl, top, left) {
      var id = this._generateUniqueId(newEl.tagName.toLowerCase());

      newEl.id = id;
      newEl.varName = this._generateVarName(newEl.id);

      var elItem = {
        element: newEl,
        id: newEl.id,
        name: newEl.tagName.toLowerCase(),
        top: top,
        left: left,
        varName: newEl.varName,
        publicMethods: newEl.publicMethods
      };

      var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());
      if (info.resizable || info.category === 'visualize') {
        elItem.resizable = true;
        elItem.width = 250;
        elItem.height = 200;
      }

      this._addElementVar(elItem);

      this._initCustomMethodsObj(elItem);

      var newElements = this._elements.slice();
      newElements.push(elItem);
      this.set('_elements', newElements);
    },
    // when delete button is clicked
    _deleteElementEvent: function (e) {
      var self = this;
      var compId = e.target.component_id;
      self._deleteElementById(compId);
    },
    _deleteElementById: function (compId) {
      var self = this;
      var compId = compId;
      console.log(compId);
      ////// temporarily removing the deleteDialog and deleteToggle
      self.$.deleteDialog.toggle();  // set the delete callback

      // // set the delete callback
      self._deleteCallback = function () {
        var embeddedEl = self.querySelector('#' + compId);

        // remove _customMethods associated with this element
        var newCustomMethods = {};

        for (var i in self._customMethods) {
          if (i !== compId) {
            newCustomMethods[i] = self._customMethods[i];
          }
        }

        self._customMethods = newCustomMethods;


        var elInArray = self.findElById(compId);  //remove all connections
        //remove all connections
        self.removeAllConnectionsFromElement(compId);  // remove element from elements array (which removes it from the shadowDOM)

        // remove element from elements array (which removes it from the shadowDOM)
        var filteredEls = self._elements.filter(function (el) {
          return typeof(el.element) != 'undefined' && el.element.id !== compId;
        });

        self.set('_elements', filteredEls);

        embeddedEl.dispose();

        // remove var from olos object
        this[embeddedEl.varName] = null;

        // remove elements
        Polymer.dom(self.$.container).removeChild(embeddedEl);
      };
    },
    removeAllConnectionsFromElement: function (elId) {
      var badConnections = this._connections.filter(function (conn, index) {
        
        //filter if element is source or target of a connection
        return (conn.source.id===elId || conn.target.id === elId);
         
      });

      var goodConnections = this._connections.filter(function (conn, index) {
        
        //filter if element is source or target of a connection
        return !(conn.source.id===elId || conn.target.id === elId)
         
      });

      this._connections = goodConnections;

      // disconnect the badConnections
      for (var i = 0 ; i < badConnections.length; i++) {
        var src = badConnections[i].source.element[badConnections[i].source.field];
        if (src instanceof AudioNode) {
          this._deleteAudioConnection(badConnections[i]);
        } else {
          // console.log('removed connection ' + src + ' is not audio!!');
        }
      }

      this._drawConnections();
    },
    // if option key was pressed, clone the element when drag is done
    _cloneElement: function (e) {
      var selection = e.target;

      // figure out the name of the element...
      var componentId = selection.componentId;
      var idSplit = componentId.split('-');
      var elNameArray = [];
      var elName = '';
      for (var i = 0; i < idSplit.length; i++) {
        if (isNaN(Number(idSplit[i]))) {
          elNameArray.push(idSplit[i]);
        }
      }
      elName = elNameArray.join('-');
      this.addNewElToLens(elName, e.x, e.y);
      var dx = e.x - (e.target.getAttribute('start-x') || 0), dy = e.y - (e.target.getAttribute('start-y') || 0);
      console.log(dx, dy);  // if other wrappers were selected, also clone those
      // if other wrappers were selected, also clone those
      for (var i = 0; i < this._selWrappers.length; i++) {
        var target = this._selWrappers[i];
        if (target === e.target) {
          return;
        } else {
          var orig = target.getBoundingClientRect();  // find each element's distance from the e.toElement
          // find each element's distance from the e.toElement
          var x = (orig.left + dx) / this._zoom;
          var y = (orig.top + dy) / this._zoom;
          this.addNewElToLens(elName, x, y);
        }
      }
    },
    /********************** Event Handlers Start ********************************/
    draggedOverContainer: function (e) {
      // Needed to enable droppedInContainer
      e.preventDefault();
    },
    droppedInContainer: function (e) {
      var self = this;

      // e.preventDefault();

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      if (e.path && e.path.length > 0 && e.path[0].classList.contains('resize') > 0) {
        self.dragResizeEnd(e);
      }
      var dataTransfer = e.dataTransfer.getData('text/plain'); 
      //data added by component-list
      ////TODO make better
      if (dataTransfer && dataTransfer.length > 0) {
        var dataSeg = dataTransfer.split(',');
        if (dataSeg.length == 1) {
          self.addNewElToLens(dataSeg[0], Math.round(e.clientX / 10) * 10 * self._zoom, Math.round(e.clientY / 10) * 10 * self._zoom);
          return;
        }
      }
    },
    clickInContainer: function (e) {
      var className = e.target.className;
      if (className.baseVal && className.baseVal.indexOf('cnxn') > -1) {
        console.log('clicked on connection');
        this.clickedOnConnection(e);
      } else {
        this._clearHighlightedConnections();
      }  // start drag
      // start drag
      if (e.target.id === 'container') {
        this.dragStartSVG(e);
      }
    },
    clickedOnDestination: function() {
      var d = this.$$('olos-destination');
      d.toggleMute();
    },
    clickedOnConnection: function (e) {
      var bezier = Polymer.dom(this.root).querySelector('#' + e.target.id);
      if (String(bezier.classList).indexOf('highlight') > -1) {
        // console.log('delete');
        this._deleteBezier(e, bezier);
      } else {
        // if not highlighted, then highlight
        this._clearHighlightedConnections();
        bezier.classList.add('highlighted');
        this._highlightedConnection = bezier;
      }
    },
    _clearHighlightedConnections: function () {
      if (this._highlightedConnection) {
        this._highlightedConnection.classList.remove('highlighted');
        this._highlightedConnection = null;
      }
    },
    // clear all _selWrappers and _selElement
    _clearSelElement: function () {
      if (this._selWrappers) {
        for (var i in this._selWrappers) {
          this._selWrappers[i].classList.remove('selected-element');
        }
      }
      this._selWrappers = [];
      this._selElement = null;
    },
    dragStartResize: function (e) {
      e.stopPropagation();
    },
    dragResize: function (e) {
      var self = this;
      var wrapper = e.target.parentNode;
      // var wrapper = selection.parentNode;  //var styles = window.getComputedStyle(wrapper);
                                           // var wrapperTop = parseInt(styles.top.replace('px',''));
                                           // var wrapperLeft = parseInt(styles.left.replace('px',''));
                                           // var w =  e.x - wrapperLeft - 65,
                                           //     h = e.y - wrapperTop - 172;
      //var styles = window.getComputedStyle(wrapper);
      // var wrapperTop = parseInt(styles.top.replace('px',''));
      // var wrapperLeft = parseInt(styles.left.replace('px',''));
      // var w =  e.x - wrapperLeft - 65,
      //     h = e.y - wrapperTop - 172;
      
      // on last call e.x and e.y are zero.     
      if(e.x === 0 && e.y === 0) {
        return;
      }

      var wrapperTop = parseInt(wrapper.getBoundingClientRect().top), wrapperLeft = parseInt(wrapper.getBoundingClientRect().left);
      var w = e.x / this._zoom - wrapperLeft / this._zoom, h = e.y / this._zoom - wrapperTop / this._zoom;


      var elementInsideId = wrapper.componentId;
      var elementInside = this.querySelector('#' + elementInsideId);
      var element = this.findElById(elementInsideId);

      // resize the actual element:
        // should resize snap?
        // var newW = Math.round(w / self._snapX) * self._snapX;
        // var newH = Math.round(h / self._snapY) * self._snapY;
      element.element.style.width = (w) + 'px';
      element.element.style.height = (h) + 'px';

      // also resize the wrapper element
      wrapper.style.width = w + 'px';
      wrapper.style.height = h + 'px';

      // also move the drag handle
      var newTransX = w - parseInt(e.target.style.left) + 5;
      var newTransY = h - parseInt(e.target.style.top) + 5;
      var newTrans = 'transform: translate(' + newTransX +'px, ' + newTransY + 'px);';
      var keepTop = e.target.style.top;
      var keepLeft = e.target.style.left;
      e.target.setAttribute('style', 'top: ' + keepTop +'; left: ' + keepLeft + '; ' + newTrans);
      e.target.style.left = (e.x - wrapperLeft);
      e.target.style.top = (e.y - wrapperTop)

      self._drawConnections();
      e.stopPropagation();
      e.preventDefault();
    },
    dragResizeEnd: function (e) {
      var wrapper = null;

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      if (e.path && e.path.length > 0 && e.path[0].classList.contains('resize') > 0) {
        wrapper = e.path[0].parentNode;
      }
      var elementInsideId = wrapper.id.replace('wrapper-', '');
      var elementInside = this.querySelector('#' + elementInsideId);
      if (typeof elementInside.resize === 'function') {
        elementInside.resize();
      }
    },
    // _dragClone: function(e, details, selection) {
    //   // TO Do
    //   console.log(e.target);
    // },
    dragStartWrapper: function (e) {
      var target = e.target;  // make this the _selElement and _selWrapper
      // make this the _selElement and _selWrapper
      this.wrapperClicked(e);  // set start-x and start-y for all _selWrappers
      // set start-x and start-y for all _selWrappers
      for (var i = 0; i < this._selWrappers.length; i++) {
        var wrapper = this._selWrappers[i];
        this._setWrapperDragStartingPoint(wrapper, e.x, e.y);
      }
      if (this._hotKeys['18']) {
        // start dragging a clone
        this._draggingClone = true;
        return;
      }
      var dragImgEl = document.querySelector('#wrapper-drag-img');
      if (!dragImgEl) {
        dragImgEl = document.createElement('span');
        dragImgEl.setAttribute('style', 'opacity: 0;');
        dragImgEl.id = 'wrapper-drag-img';
        dragImgEl.textContent = 'a';
        document.body.appendChild(dragImgEl);
      }  //keep dragImage outside the canvas
      //keep dragImage outside the canvas
      e.dataTransfer.setDragImage(dragImgEl, -2000, -2000);
    },
    // set starting position of a drag for any target, not based on an event. Called by dragStartWrapper
    _setWrapperDragStartingPoint: function (target, x, y) {
      target.setAttribute('start-x', x);
      target.setAttribute('start-y', y);
    },
    dragWrapper: function (e) {
      if (this._hotKeys['18']) {
        // dragging a clone
        return;
      }

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      if (e.path[0].classList && e.path[0].classList.length > 0 && (e.path[0].classList.contains('resize') || e.path[0].classList.contains('arrow'))) {
        return false;
      }
      var target = e.target;
      for (var i = 0; i < this._selWrappers.length; i++) {
        var wrapper = this._selWrappers[i];
        var dx = e.x / this._zoom - (wrapper.getAttribute('start-x') / this._zoom || 0), dy = e.y / this._zoom - (wrapper.getAttribute('start-y') / this._zoom || 0);
        this._updateWrapperLocation(e, wrapper, dx, dy);
      }
      this._drawConnections();
    },
    _updateWrapperLocation: function (e, target, dx, dy) {
      // keep the dragged position in the data-x/data-y attributes, add snap residue from previous drag
      var x = (parseFloat(target.getAttribute('data-x')) || 0) + dx + (parseFloat(target.getAttribute('residue-x')) || 0);
      var y = (parseFloat(target.getAttribute('data-y')) || 0) + dy + (parseFloat(target.getAttribute('residue-y')) || 0);
      var sx = Math.round(x / this._snapX) * this._snapX;
      var sy = Math.round(y / this._snapY) * this._snapY;
      target.setAttribute('residue-x', x - sx);
      target.setAttribute('residue-y', y - sy);  // translate the element. 
                                                 // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      // translate the element. 
      // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      if (e.x !== 0 || e.y !== 0) {

        // store transform for the udpateStyle method
        var componentId = e.target.componentId; //('component-id');
        var componentInfo = this.findElById(componentId);
        componentInfo.transform = 'translate(' + sx + 'px, ' + sy + 'px)';

        // update the position attributes, and transform to actually move the element
        target.style.transform = 'translate(' + sx + 'px, ' + sy + 'px)';

        //update component as well since <content> is not working.
        //var componentId = target.componentId;
        //var componentDom = Polymer.dom(this).querySelector('#'+componentId);
        componentInfo.element.style.transform = 'translate('+sx+'px, '+(sy)+'px)';


        target.setAttribute('data-x', sx);
        target.setAttribute('data-y', sy);
        target.setAttribute('start-x', e.x);
        target.setAttribute('start-y', e.y);
      }
      this._renderContainerTemplate();
    },
    dragEndWrapper: function (e) {
      // console.log('done dragging!');
      if (this._draggingClone) {
        this._draggingClone = false;
        this._cloneElement(e);
        return;
      }  //if resize is being dragged don't do anything (stopPropagation is not doing anything)
      //if resize is being dragged don't do anything (stopPropagation is not doing anything)
      var target = e.target;
      target.setAttribute('residue-x', 0);
      target.setAttribute('residue-y', 0);
    },
    wrapperClicked: function (e) {
      var wrapperEl = e.currentTarget;
      var elementId = wrapperEl.id;
      elementId = elementId.substring(8, elementId.length);
      var el = this.findElById(elementId).element;
      if (this._selElement != el) {
        // unhighlight other selected element if this was not one of them
        if (wrapperEl.classList.contains('selected-element')) {
          console.log('already selected');
        } else {
          this._clearSelElement();
          console.log('not already selected');
        }
        this._selElement = el;
      }
      if (this._selWrappers.indexOf(wrapperEl) === -1) {
        wrapperEl.classList.add('selected-element');
        this._selWrappers.push(wrapperEl);
      }
    },
    // SVG drag events, also called on mousedown
    dragStartSVG: function (e) {
      // clear this._selWrappers [TO DO: unless Shift is clicked]
      this._selWrappers = [];
      this._makeDragArea = true;
      this._selectingElByDrag = false;
      this._dragArea = this._createDragArea(e);
      this.$.svg.insertBefore(this._dragArea, this.$.svg.firstChild);
    },
    // called when makeDragArea is true
    dragSVG: function (e) {
      if (this._makeDragArea) {
        this._updateDragArea(e, this._dragArea);
      }
    },
    // also called on mouseup
    dragEndSVG: function (e) {
      if (!this._dragArea) {
        return;
      }  // remember the old sel el
      // remember the old sel el
      var oldSelElement = this._selElement;  // dimension of the rectangle:
      // dimension of the rectangle:
      var dragRect = this._dragArea.getBoundingClientRect();  // find any elements that intersect with the drag area, sort out which are _selElement and _selWrappers
      // find any elements that intersect with the drag area, sort out which are _selElement and _selWrappers
      for (var i in this._elements) {
        var el = this._elements[i];
        var wrapperEl = Polymer.dom(this.root).querySelector('#wrapper-' + el.id);  // get element dimensions
        // get element dimensions
        var elRect = wrapperEl.getBoundingClientRect();  // compare and if there is overlap, add class
        // compare and if there is overlap, add class
        var overlap = this._boundingRectOverlap(elRect, dragRect);
        if (overlap) {
          // select elements that overlap
          if (this._selWrappers.indexOf(wrapperEl) < 0) {
            this._selWrappers.push(wrapperEl);
          }
          wrapperEl.classList.add('selected-element');  // remember selected element if it overlaps
          // remember selected element if it overlaps
          if (el.element === oldSelElement) {
            this._selElement = el.element;
          }
        } else {
          // otherwise remove selection
          if (wrapperEl.classList.contains('selected-element')) {
            wrapperEl.classList.remove('selected-element');
          }
          if (this._selElement === el.element) {
            this._selElement = null;
          }
        }
      }
      this._clearDragArea();
    },
    // helper method
    _boundingRectOverlap: function (rect1, rect2) {
      var overlap = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
      return overlap;
    },
    // handle selecting elements by their wrapper during drag
    dragOverWrapper: function (e) {
    // if (this._makeDragArea) {
    //   if (!this._selectingElByDrag) {
    //     this._selectingElByDrag = true;
    //   }
    //   console.log('drag over: ' + e.target.id);
    // }
    },
    // create a rectangle to show drag area
    _createDragArea: function (e) {
      var x = e.x / this._zoom, y = e.y / this._zoom;
      var svgns = 'http://www.w3.org/2000/svg';
      var rect = document.createElementNS(svgns, 'rect');
      rect.setAttributeNS(null, 'opacity', 0.2);
      rect.setAttributeNS(null, 'x', x);
      rect.setAttributeNS(null, 'y', y);
      rect.setAttributeNS(null, 'width', '0');
      rect.setAttributeNS(null, 'height', '0');
      rect.setAttributeNS(null, 'fill', '#D1D1D1');
      rect.startX = x;
      rect.startY = y;
      return rect;
    },
    // update drag rectangle
    _updateDragArea: function (e, rect) {
      var svgns = 'http://www.w3.org/2000/svg';
      var startX = rect.startX;
      var startY = rect.startY;
      var deltaX = e.x / this._zoom - startX;
      var deltaY = e.y / this._zoom - startY;
      if (deltaX < 0) {
        rect.setAttributeNS(null, 'x', startX + deltaX);
        deltaX = Math.abs(deltaX);
      }
      if (deltaY < 0) {
        rect.setAttributeNS(null, 'y', startY + deltaY);
        deltaY = Math.abs(deltaY);
      }
      rect.setAttributeNS(null, 'width', deltaX);
      rect.setAttributeNS(null, 'height', deltaY);
    },
    _clearDragArea: function () {
      if (this._dragArea) {
        this.$.svg.removeChild(this._dragArea);
      }
      this._makeDragArea = false;
      this._dragArea = null;  //this.$.svg.innerHTML = '';
    },
    //this.$.svg.innerHTML = '';
    dragOutArrowStart: function (e) {
      this.draggedEl = e.target;

      //to stop wrapper drag to be called
      e.stopPropagation();
      if (!this.svgTop || !this.svgLeft) {
        var svgRect = this.$.svg.getBoundingClientRect();
        this.svgTop = svgRect.top;
        this.svgLeft = svgRect.left;
      }
      this.startPointX = e.x / this._zoom - this.svgLeft;
      this.startPointY = e.y / this._zoom - this.svgTop;  // create temp bezier
      // create temp bezier
      
      //TODO cache
      //var tempPath = Polymer.dom(this.root).querySelector('#temp_path');
      
      // console.log('points', this.startPointX, this.startPointY, this.tempPath);
      
      if (!this.tempPath) {

        this._addBezierPath(this.startPointX, this.startPointY, this.startPointX, this.startPointY, 70, 'temp_path');  
        this.tempPath = Polymer.dom(this.root).querySelector('#temp_path');
      }
      else {
          this.tempPath.style.display = 'block';

      }
    },
    //this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70, 'temp_path');
    dragOutArrow: function (e) {

      //TODO cache
      //var tempPath = Polymer.dom(this.root).querySelector('#temp_path');  // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      if (e.x !== 0 || e.y !== 0) {
        var newPath = this._calculateBezierPath(this.startPointX, this.startPointY, e.x / this._zoom - this.svgLeft, e.y / this._zoom - this.svgTop, 70);
        this.tempPath.setAttribute('d', newPath);
      }
    },
    dragOutArrowEnd: function (e) {
      
        // remove method is not working for tempPath when using Polumer.dom...querySelector useing document.querySelector instead
       
      //var tempPath = Polymer.dom(this.root).querySelector('#temp_path');
      if (this.tempPath) {
        this.tempPath.style.display = 'none';
        //tempPath.remove();
      }
      
     /*
      var tempPath = document.querySelector('#temp_path');
      if (tempPath) {
        tempPath.style.display = 'none';
        //tempPath.remove();
      }
      */


    },
    dragOverInArrow: function (e) {
      var tooltip = document.getElementsByClassName(e.target.dataset.tooltip)[0];
      tooltip.show();
      //important! needed to allow drop
      e.preventDefault();
    },
    dragEnterInArrow: function (e) {
      var tooltip = document.getElementsByClassName(e.target.dataset.tooltip)[0];
      tooltip.show();
      e.target.classList.add('drag-over');
    },
    dragLeaveInArrow: function (e) {
      var tooltip = document.getElementsByClassName(e.target.dataset.tooltip)[0];
      tooltip.hide();
      e.target.classList.remove('drag-over');
    },
    droppedOnInArrow: function (e) {
      
      //TODO: depending on classnames is not a safe solution. add componentId or something similar and universal

      e.target.classList.remove('drag-over');
      var className = e.target.parentNode.classList[0]; //selection.classList[0],
      var targetElementId = className.substring(0, className.lastIndexOf('-'));
      var targetField = className.substring(className.lastIndexOf('-') + 1, className.length);
      var source = this.findElById(this.draggedEl.classList[0]); 
      var target = this.findElById(targetElementId);
      this._connectAttributes(source, 'output', target, targetField);
      this._drawConnections();
      e.stopPropagation();
    },
    droppedOnParamArrow: function(e) {
      var self = this;
      var selection = e.target;
      var tooltip = document.getElementsByClassName(selection.dataset.tooltip)[0];
      var target = this.findElById(selection.dataset.elt);
      // var targetField = document.getElementById(selection.dataset.param);
      var targetField = selection.dataset.param;
      var source = self.findElById(self.draggedEl.classList[0]);

      selection.classList.remove('drag-over');
      tooltip.hide();



      // var className = selection.classList[0],
      //     targetElementId = className.substring(0, className.lastIndexOf('-') ),   
      //     targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),
      //     source = self.findElById(self.draggedEl.classList[0]),
      //     target = self.findElById(targetElementId);
      console.log(source, target, targetField);
      // connect source to audioParam
      this._connectAttributes(source, 'output', target, targetField);
      // self._drawConnections();
      e.stopPropagation();
    },
    arrowClicked: function (e) {
      //e.stopPropagation();
      var wrapper = null;

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      for (var i = 0; i < e.path.length && !wrapper; i++) {
        if (e.path[i].classList.contains('wrapper')) {
          wrapper = e.path[i];
        }
      }
      var sourceTarget = e.path[0].classList.contains('inputMarker') ? 'target' : 'source';
      var elementInsideId = wrapper.componentId;  //var elementInside = this.findElById(elementInsideId);
      //var elementInside = this.findElById(elementInsideId);
      var connection = this._connections.filter(function (conn) {
        if (conn[sourceTarget].id === elementInsideId) {
          return true;
        }
      });
      if (connection.length > 0) {
        var marker = e.path[0];
        var bezierCssPath = '#container #svg #' + connection[0].source.id + '-' + connection[0].target.id;
        var bezier = Polymer.dom(this.root).querySelector(bezierCssPath);
        if (connection[0].highlighted) {
          connection[0].highlighted = false;
          marker.classList.remove('highlighted');
          bezier.classList.remove('highlighted');
        } else {
          connection[0].highlighted = true;
          marker.classList.add('highlighted');
          bezier.classList.add('highlighted');
        }
      }
    },
    dragOverDestination: function(e) {
    },
    droppedOnDestination: function(e) {
      console.log('drop on destino!');
      console.log('dragged el', this.draggedEl.classList);

      e.target.classList.remove('drag-over');
      var className = e.target.classList[0],
          // targetElementId = className.substring(0, className.lastIndexOf('-') ),   
          // targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),      
          source = this.findElById(this.draggedEl.classList[0]),
          target = this.destination;
      // console.log('clasname: ' + className, 'target elt: ' + targetElementId, targetField, source, target);

        // make the actual connection, returns true if connection was made
        if ( this.makeConnection(source.element, 'output', target, 'input') ) {

          var srcClone = {
            id: source.id,
            name: source.name,
            element: source.element,
            field: 'output'
          };
          var targetClone = {
            id: target.id,
            name: target.id,
            element: target,
            field: 'input'
          };

          this._connections.push({
            source: srcClone,
            target: targetClone,
            // listener: listener // reference to listener function
          });

          this._drawConnections();
          return true;
        }
    },
    _deleteBezier: function (e, bezier) {
      var srcId, dstId;
      var self = this;
      self.$.deleteDialog.toggle();  // set the delete callback
      // set the delete callback
      self._deleteCallback = function () {
        var idSplit = bezier.id.split('-');
        srcId = idSplit.slice(0,3).join('-');
        dstId = idSplit.slice(3, idSplit.length).join('-');

        self._spliceAudioConnections(srcId, dstId);
      };
    },
    deleteConnectionByID: function (e, dstId) {
      this._connections = this._connections.filter(function (connection) {
        return connection.target.id !== dstId;
      });
      if (e) {
        var marker = e.path[1];
        marker.classList.remove('highlighted');
      }
      this._drawConnections();
    },
    // delete audio connections
    _spliceAudioConnections: function(srcId, dstId) {
      var srcNode, srcElem;
      var dst;
      var src;
      var reConnect = true;

      if (this._highlightedConnection) {
        var splitID = this._highlightedConnection.id.split('-');
        src = splitID[0]+'-'+splitID[1]+'-'+splitID[2];
        dst = splitID[3] + '-' + splitID[4] + '-' + splitID[5];
      }
      else {
        var wrapper = null;
        for(var i = 0; i< e.path.length && !wrapper; i++) {
          if(e.path[i].classList.contains('wrapper')) {
            wrapper = e.path[i];
          }
        }
        dst = wrapper.getAttribute('component-id');
      }

      for (var i = 0; i < this._connections.length; i++) {

        if (this._connections[i].target.id === dstId && this._connections[i].source.id === srcId) {
          srcNode = this._connections[i].source.field;
          srcElem = this._connections[i].source.element;
          dstNode = this._connections[i].target.field;
          dstElem = this._connections[i].target.element;

          if (dstElem[dstNode] instanceof Array) {
            // if destination is an array, make it empty
            dstElem[dstNode] = [];
            this._connections.splice(i,1);
          }

          else if (typeof(srcElem[srcNode].disconnect) === 'function'){
            srcElem[srcNode].disconnect();
            this._connections.splice(i,1);
          }

          else if (srcElem.outputConnections instanceof Array) {
            // find the one with this ID
            for (var j = 0; j < srcElem.outputConnections.length; j++) {
              console.log(srcElem.outputConnections[j].destination.id)
              if (srcElem.outputConnections[j].destination.id === dstElem.id) {
                srcElem.outputConnections.splice(j,1);
                this._connections.splice(i,1);
                console.log('spliced!');

                reConnect = false;
              }
            }
          }

          else {
            console.log('unable to disconnect ' + srcElem[srcNode]);
          }

        }
      }
      console.log('anything to reconnect?');
      console.log(reConnect);
      if (reConnect) {
        // if srcNode was connected to any other nodes, re-connect them
        for (var j = 0; j < this._connections.length; j++) {
          var src = this._connections[j].source;
          if (src.element === srcElem && src.field === srcNode) {
            var dstNode = this._connections[j].target.field;
            var dstElem = this._connections[j].target.element;
            try {
              self.makeConnection(srcElem, srcNode, dstElem, dstNode);
              // srcElem[srcNode].connect(dstElem[dstNode]);
            } catch(e) {
              console.log(e);
            }
          }
        }
      }

      this._highlightedConnection.classList.remove('highlighted');
      this._highlightedConnection = null;

      this._drawConnections();

    },
    _deleteAudioConnection: function(connection) {
      var self = this;
      var srcElem = connection.source.element;
      var srcField = connection.source.field;
      var srcNode = srcElem[srcField];
      try{
        srcNode.disconnect();
      } catch(e) {
        self.deleteConnection(connection);
      }

      // reconnect any connections that have srcNode as the source
      for (var i = 0; i < this._connections.length; i++) {
        var conn = this._connections[i];

        if (conn.source.element === srcElem && conn.source.field === srcField) {
          var dstElem = conn.target.element;
          var dstField = conn.target.field;
          console.log(dstElem);
          // do it this way for olos-params
          self.makeConnection(srcElem, srcField, dstElem, dstField)

          // var dstNode = dstElem[dstField];
          // srcNode.connect(dstNode);
        }
      }

    },
    toggleSetting: function (e) {
      var button = e.target,
          componentId = button.getAttribute('component-id'),
          elementInfo = this.findElById(componentId);

      button.toggleClass('open');
      elementInfo.settingOpen = elementInfo.settingOpen ? false : true;
      if(elementInfo.settingOpen) {
        elementInfo.element.style.opacity = 1;
        elementInfo.element.style.height = 'auto';     
      }
      else {
        elementInfo.element.style.opacity = 0;
        elementInfo.element.style.height = '0%';
      }
    },
    keydownHandler: function (e) {
      var self = this;

      // prevent backspace acting as browser back button
      // via http://stackoverflow.com/a/2768256/2994108
      var doPrevent = false;
      if (e.keyCode == 8) {
        var rx = /INPUT|SELECT|TEXTAREA/i;

        var d = e.srcElement || e.target;
        if (rx.test(d.tagName.toUpperCase() )) {
          doPrevent = d.readOnly || d.disabled;
        } else {
          doPrevent = true;
        }
      }
      if (doPrevent) {
        e.preventDefault();
      }

      switch (e.keyCode) {
      // if deleteKey:
      case 8:
        if (!doPrevent) return;

        // if bezier was selected, delete that. Otherwise, delete element
        if (self._highlightedConnection) {
          self._deleteBezier(e, self._highlightedConnection);
        } else if (self._selWrappers.length > 0) {
          for (var i = 0; i < self._selWrappers.length; i++) {
            var _id = self._selWrappers[i].componentId;
            self._deleteElementById(_id);
          }
        }
        e.stopPropagation();
        break;  // zoom with -_ (189) and += (187)
      // zoom with -_ (189) and += (187)
      case 189:
        self.zoomOut();
        break;
      case 187:
        self.zoomIn();
        break;
      default:
        if (typeof self._hotKeys[e.which] !== 'undefined') {
          self._hotKeys[e.which] = true;
        }
        break;
      }
    },
    keyupHandler: function (e) {
      var self = this;
      if (self._hotKeys[e.which]) {
        self._hotKeys[e.which] = false;
      }
    },
    mouseoutHandler: function (e) {
      this._clearDragArea();
    },
    /********************** Event Handlers End ********************************/
    showDataBtn: function () {
      this._showDataTable = !this._showDataTable;
      this.$.showDataBtn.classList.toggle('active');
      [].forEach.call(Polymer.dom(this.root).querySelectorAll('.data-preview'), function (el) {
        el.style.maxHeight = el.style.maxHeight == '0px' ? '100px' : '0px';
      });
    },
    showSaveDialog: function () {
      this.$.savedetails.toggle();
    },
    /**
     * The functions which sets the connection (two way binging) between two element attrubutes
     * There is not really a sourc/target distinction in the observer since it is a two way binging (in theory)
     * but the distinction is conceptual and in UI.
     * @param  {[type]} source      Source element
     * @param  {[type]} sourceField The attribute to connect from source element
     * @param  {[type]} target      Target element
     * @param  {[type]} targetField The attribute to connect from target element
     * @return {None}             
     */
    _connectAttributes: function (source, sourceField, target, targetField) {
      var self = this;  //find the index of connection which has the same target
      //find the index of connection which has the same target
      
      var listener = null;

      var connWithSameTargetIndex = self._connections.reduce(function (value, conn, index) {
        if (conn.target.id === target.id && conn.target.field === targetField) {
          return index;
        }
      }, -1);
      // and remove it from connections array
      if (connWithSameTargetIndex > -1) {
        self._connections.splice(connWithSameTargetIndex, 1);
      }

      if (source === target) {
        //if a bubble was dropped on itself
        alert('You cannot make a connection within the same element');
        return false;
      } else {
        // make the connection in the elements array
        //target.inputConnectedTo = source;  // not needed
        
        /*
          using lens-output-change works for output-input connection. might have better performance than observation
          but not a universal solution. lets try:
         */

        if(sourceField.indexOf('output') == 0 && targetField.indexOf('input') == 0) {
          listener = function(e) {
            console.log(e);

            // find the actual output?
            // var output = target.element.output;
            var newOutput = e.detail;
            target.element[targetField] = newOutput;
          }
          source.element.addEventListener('olos-ouput-changed', listener);
        }
        
        
        /*
        
          //TODO: not working. possible solution: http://stackoverflow.com/questions/30615549/data-binding-in-a-dynamically-inserted-polymer-element
         
        var observer = new PathObserver(source.element, sourceField);
        observer.open(function (newValue, oldValue) {
          target.element[targetField] = newValue;
        });
        */
        var srcClone = {
          id: source.id,
          name: source.name,
          element: source.element,
          field: sourceField
        };
        var targetClone = {
          id: target.id,
          name: target.name,
          element: target.element,
          field: targetField
        };

        // make the actual connection, returns true if connection was made
        if ( this.makeConnection(source.element, sourceField, target.element, targetField) ) {

          this._connections.push({
            source: srcClone,
            target: targetClone,
            listener: listener // reference to listener function
          });
          return true;
        }
      }
    },
    makeConnection: function(src, srcPort, dst, dstPort, svgPath) {

      var isAudioParam = dstPort.indexOf('Param') > -1 ? true : false;
      var connectorShape = {};

      if (this._dragObj && this._dragObj.connectorShape) {
        connectorShape = this._dragObj.connectorShape;
      }

      if (!src.outputConnections) {
        src.outputConnections = [];
      }

      var connector = {};
      connector.line = connectorShape;
      connector.source = src;
      connector.destination = dst;
      connector.sourcePort = src[srcPort];
      connector.destinationPort = dst[dstPort];
      connector.destinationLabel = dstPort;
      src.outputConnections.push(connector);

      // Put an entry into the destinations's inputs
      if (!dst.inputConnections){
        dst.inputConnections = new Array();
      }
      connector = new Object();
      connector.line = connectorShape;
      connector.source = src;
      connector.destination = dst;
      connector.sourcePort = src[srcPort];
      connector.destinationPort = dst[dstPort];
      connector.destinationLabel = dstPort;
      dst.inputConnections.push(connector);

      connectorShape.inputConnection = connector;
      connectorShape.destination = dst;
      connectorShape = null;

      // save connections to component source and destination
      if (src[srcPort] instanceof AudioNode && dst[dstPort] instanceof AudioNode) {
        src[srcPort].connect(dst[dstPort]);
      } else if (dst[dstPort] instanceof AudioParam) {
        console.log('audio param connection!');
        src[srcPort].connect(dst[dstPort]);
      }

      // new solution for matrix connecting to olos-param
      else if (dst[dstPort] instanceof Object && src[srcPort] instanceof Array) {
        return true;
      }

      // new solution for audioNode connecting to olos-param
      // TO DO: disconnect this case
      else if (src[srcPort] instanceof AudioNode && dst[dstPort] instanceof Object) {

        try {
          src[srcPort].connect(dst[dstPort]);
        } catch(e) {
          throw 'unable to connectaaaaaaa';
        }
      }

      else {
        return false;
      }

      return true;
    },
    _drawConnections: function () {
      var self = this;
      var arrowOffsetY = 7;
      var arrowOffsetX = 7;
      var bezierCurveX = 70;  // the larger the value the smoother the curve
                              //clear all paths. since it is not done offten it is fine to do it in a not optimized way
      //TODO. dont recreate. below line is WRONG. performance problem when drgging wrapper!
      // the larger the value the smoother the curve
      //clear all paths. since it is not done offten it is fine to do it in a not optimized way
      self.$.svg.innerHTML = '';
      //make tempPath null since it is deleted above by innerHTML=''. TODO fix above and remove this line
      self.tempPath = null;

      for (var i = 0; i < self._connections.length; i++) {
        var conn = self._connections[i];
        var srcEl = conn.source.element || Polymer.dom(self.root).querySelector('#' + conn.source.id);  //TODO do this in initialization method
        //TODO do this in initialization method
        var targetEl = conn.target.element || Polymer.dom(self.root).querySelector('#' + conn.target.id);
        //TODO save if querying for next time.
        
        //TODO move to a better place to set them in the begining
        if (!conn.source.wrapper) {
          console.log('querying wrapper');
          conn.source.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + srcEl.id);
        }
        if (!conn.target.wrapper) {
          conn.target.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + targetEl.id);
        }

        var srcWrapper = conn.source.wrapper; //Polymer.dom(self.root).querySelector('#wrapper-' + srcEl.id);
        var targetWrapper = conn.target.wrapper; //Polymer.dom(self.root).querySelector('#wrapper-' + targetEl.id);
        var srcRect = srcWrapper.getBoundingClientRect();
        var targetRect = targetWrapper.getBoundingClientRect();
        var svgRect = self.$.svg.getBoundingClientRect();
        var otherInputOffset = conn.target.field === 'input' ? 0 : 16;
        var startX = (srcRect.right - svgRect.left + arrowOffsetX) / self._zoom;  //srcRect.left + srcRect.width + 30 - containerOffsetX;
        //srcRect.left + srcRect.width + 30 - containerOffsetX;
        var startY = (srcRect.top - svgRect.top + arrowOffsetY) / self._zoom;
        var endX = (targetRect.left - svgRect.left - arrowOffsetX) / self._zoom;
        var endY = (targetRect.top - svgRect.top + arrowOffsetY + otherInputOffset) / self._zoom;
        self._addBezierPath(startX, startY, endX, endY, bezierCurveX, srcEl.id + '-' + targetEl.id, conn.highlighted);
      }
    },
    scaffold: function () {
      var structure = this.structure;
      if (typeof this.structure === 'string' && this.structure.length > 0) {
        structure = JSON.parse(this.structure);
      }
      if (structure.elements) {
        this.scaffoldFromData(structure.elements, structure.connections, structure.outputComponents);
      }
    },
    /**
     * returns final result component to create viewer
     * @return {Object} e.g {componentName: 'lens-v-z-g-bar-chart-0', componentState: (all state data including input)}
     */
    getFinalResult: function () {
      if (this._outputComponents.length > 0) {
        //TODO: multiple outputComponents
        var component = _.clone(this.findElById(this._outputComponents[0]));  //for viz components save input, for the rest save output
        //for viz components save input, for the rest save output
        if (component.name.indexOf('-viz-') > 0) {
          component.input = component.element.input;
        } else {
          component.output = component.element.output;
        }
        var componentName = component.name;
        var componentState = JSON.stringify(component, this.removeDomObjects);
        return {
          componentName: componentName,
          componentState: componentState
        };
      }
    },
    /**
     * Scaffold a new th-connector from state data. Usage: 
     *  var newConnector = document.createElement('th-connector');
     *  newConnector.scaffoldFromData(elements, connections)
     *  where elements and connections are parsed json files coming form dumpData
     * @param  {Object} elements    elements state data
     * @param  {Object} connections connections
     * @return {None}             
     */
    scaffoldFromData: function (elements, connections, outputComponents) {
      this._elements = elements;
      this._outputComponents = outputComponents;
      elements.forEach(function (el) {
        var alreadyExist = this.querySelector('#' + el.id);
        if (!alreadyExist) {
          var domEl = document.createElement(el.name);
          this.$.component_list.checkAndImport(domEl, function () {
            domEl.style.width = '100%';
            domEl.style.height = '100%';
            domEl.id = el.id;
            if (el.name === 'lens-input-paste') {
              domEl.output = el.output;
            } else {
              Object.keys(domEl.properties).forEach(function (attr) {
                if (attr !== 'input' && attr !== 'output' && el[attr]) {
                  domEl[attr] = el[attr];
                }
              });
            }
            el.element = domEl;
            Polymer.dom(this.root).appendChild(domEl);
          }.bind(this));
        }
      }.bind(this));  //delay to make sure position of elements are final
      //delay to make sure position of elements are final
      setTimeout(function () {
        this.setConnections(connections);
      }.bind(this), 1000);  //newConnector._drawConnections()
    },
    //newConnector._drawConnections()
    setConnections: function (connections) {
      this._connections = connections;
      this._connections.forEach(function (connection) {
        if (!connection.source.element) {
          connection.source.element = Polymer.dom(self.root).querySelector('#' + connection.source.id);
        }
        if (!connection.target.element) {
          connection.target.wrapper = Polymer.dom(self.root).querySelector('#' + connection.target.id);
        }

        if (!connection.source.wrapper) {
          connection.source.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + connection.source.id);
        }
        if (!connection.target.wrapper) {
          connection.target.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + connection.target.id);
        }

        this._connectAttributes(connection.source, 'output', connection.target, connection.target.field || 'input');
      }.bind(this));
      this._drawConnections();
    },
    dumpData: function () {
      var self = this;
      var toDumpEls = _.map(this._elements, function (el) {
        var domObject = el.element;
        var cloned = _.clone(el);
        Object.keys(domObject.properties).forEach(function (attr) {
          //ignore input attribute and output (except where the component is th-table-data)
          if (attr === 'chartData' || attr.indexOf('input') === 0 || attr === 'output' && el.name !== 'lens-input-paste') {
            return;
          }
          cloned[attr] = domObject[attr];
        });
        return cloned;
      });
      var retObj = {
        elements: toDumpEls,
        connections: this._connections,
        outputComponents: this._outputComponents
      };
      var ret = JSON.stringify(retObj, this.removeDomObjects);  //var connectionsJSON = JSON.stringify(this._connections , this.removeDomObjects);
      //var connectionsJSON = JSON.stringify(this._connections , this.removeDomObjects);
      return ret;
    },
    _saveLens: function () {
      var btn = document.getElementById('saveLensBtn');
      if (typeof btn !== 'undefined') {
        btn.click();
        console.log('btn!');
      } else {
        console.log('no button');
      }
    },
    removeDomObjects: function (key, value) {
      if (value instanceof HTMLElement)
        return undefined;
      else
        return value;
    },

    /**
     *  Find and return a Lens component by ID,
     *  for example ``lens-input-csv-0``. Searches
     *  the _elements array for an object with the ID.
     *  
     *  @method findElById
     *  @param  {String} id ID of the component
     *  @return {Object}    Lens component
     */
    findElById: function (id) {
      var self = this;
      element = self._elements.filter(function (el) {
        return el.id === id;
      })[0];
      return element;
    },
    /**
     * Checks if a componenet has input attributes (any attribute which is named input*)
     * @param  {Object} published Object containing all published attributes
     * @return {Object}           list of attributes that are input.
     */
    _checkForInputAttr: function (index) {
      var published = this._elements[index].element.properties;
      if (!published) {
        return false;
      }
      var attrs = Object.keys(published).filter(function (item) {
        return item.indexOf('input') > -1;
      });
      return attrs;
    },
    /**
     * Checks if a componenet has output attributes.
     * @param  {Object} published Object containing all published attributes
     * @return {boolean}       True if component has output attribute (only one)
     */
    _checkForOutputAttr: function (index) {
      var published = this._elements[index].element.properties;
      if (!published) {
        return false;
      }
      return Object.keys(published).indexOf('output') > -1 ? true : false;
    },
    /**
     *  Checks if a component has audioParams. AudioParams must have 'param'
     *  in the name and be published attributes.
     *  
     *  @param  {Object} published Object containing all published attributes
     *  @return  {Oobject} list of attributes that are audioParams.
     */
    _checkForAudioParams: function(index) {
      var published = this._elements[index].element.properties;
      if(!published) {
        return false;
      }
      var attrs = Object.keys(published).filter(function(item) {
        return item.toLowerCase().indexOf("param") > -1;
      });

      return attrs;
    },
    /**
     * Generates unique ids for components
     * @param  {String} elName Component name
     * @return {[type]}        Unique component id
     */
    _generateUniqueId: function (elName) {
      var self = this;
      var num = 0;
      var tagsWithSameName = self._elements.filter(function (elem) {
        return elem.name == elName;
      });
      if (tagsWithSameName) {
        num += tagsWithSameName.length;
      }
      var uniqueId = elName + '-' + num;
      return uniqueId;
    },
    _calculateBezierPath: function (startX, startY, endX, endY, handleOffsetX) {
      // make handleOffsetX larger when source element is on the right side of target
      if (startX > endX) {
        handleOffsetX *= 2;
      }
      var distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));  // decrease handleOffsetX when too close...
      // decrease handleOffsetX when too close...
      if (distance < 100) {
        handleOffsetX /= 2;
      }
      if (distance < 50) {
        handleOffsetX /= 4;
      }
      var path = 'M' + parseInt(startX) + ',' + parseInt(startY) + ' C' + parseInt(startX + handleOffsetX) + ',' + parseInt(startY) + ' ' + parseInt(endX - handleOffsetX) + ',' + parseInt(endY) + ' ' + parseInt(endX) + ',' + parseInt(endY);
      return path;
    },
    _addBezierPath: function (startX, startY, endX, endY, handleOffsetX, id, highlighted) {
      var aLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      var path = this._calculateBezierPath(startX, startY, endX, endY, handleOffsetX);
      aLine.setAttribute('d', path);
      aLine.setAttribute('stroke', '#555');  // conn.source.color);
      // conn.source.color);
      aLine.setAttributeNS(null, 'stroke-width', '5');
      aLine.setAttribute('fill', 'none');
      if (id) {
        aLine.setAttribute('id', id);
      }  // add class "cnxn"
      // add class "cnxn"
      aLine.setAttribute('class', 'cnxn');
      if (highlighted) {
        aLine.classList.add('highlighted');
      }

      // save to global dragObj
      this._dragObj.connectorShape = aLine;

      Polymer.dom(this.$.svg).appendChild(aLine);
    },
    // zoom either to a specified amount, or add this._zoomStep
    zoomIn: function (amt) {
      if (typeof amt === 'number') {
        this._zoom = amt <= this._zoomMax ? amt : this._zoomMax;
        return;
      }
      if (this._zoom + this._zoomStep <= this._zoomMax) {
        this._zoom += this._zoomStep;
      } else {
        throw 'already zoomed max';
      }
    },
    // zoom either to a specified amount, or subtract this._zoomStep
    zoomOut: function (amt) {
      if (typeof amt === 'number') {
        this._zoom = amt >= this._zoomMin ? amt : this._zoomMin;
        return;
      }
      if (this._zoom - this._zoomStep >= this._zoomMin) {
        this._zoom -= this._zoomStep;
      } else {
        throw 'already zoomed min';
      }
    },
    _zoomChanged: function () {
      this.$.container.style.transform = 'scale(' + this._zoom + ', ' + this._zoom + ')';
    },
    // delete modal
    _noDelete: function () {
      this.$.deleteDialog.close();
    },
    _yesDelete: function () {
      this.$.deleteDialog.close();
      this._deleteCallback();
      this._deleteCallback = null;
    },
    listeners: {
      keydown: 'keydownHandler',
      keyup: 'keyupHandler',
      mouseout: 'mouseoutHandler'
    },
    // compute
    computeElementsEmpty: function() {
      //console.log('compute eq 0' , _elements, this._elements);
      return !this._elements || this._elements.length === 0;
    },

    computeElementId: function(index) {
      return this._elements[index].id;
    },

    computeLengthEqualsZero: function(item) {
      return item.length === 0;
    },
    computeWrapperId: function (el) {
      //console.log('id', el, el.id);
      return 'wrapper-' + el.id;
    },

    computeWrapperStyles: function (el) {
      return 'top: ' + el.top + 'px; left: ' + el.left + 'px; transform: ' + el.transform + '; width: ' + (el.resizable ? 0 : el.width) + 'px; height: ' + (el.resizable ? 0 : el.height) + 'px';
    },

    computeWrapperClass: function (el) {
      return 'wrapper ' + el.name;
    },

    computeCollapseId: function (el) {
      return 'collapse-' + el.id;
    },

    computeResizeStyle: function(el) {
      return 'top: ' + (el.height + 10) + 'px; left: ' + (el.width + 10) + 'px; transform: translate(0px, 0px);';
    },


    computeLengthGreaterThanZero: function(item) {
      return item.length > 0;
    },


    computeClass: function (_selElement, _showDataTable) {
      return 'data-preview ' + this.tokenList({ visible: _showDataTable && _selElement.input && _selElement.input.length > 0 });
    },

    computeIfInput: function (_selElement, _showDataTable) {
      return _showDataTable && _selElement.input && _selElement.input.length > 0;
    },

    computeIfOutput: function (_selElement, _showDataTable) {
      return _showDataTable && _selElement.output && _selElement.output.length > 0;
    },

    computeIfResizable: function (el) {
      return !el.resizable;
    },
    computeClassInArrow: function (el, ins) {
      return el.element.id + '-' + ins + ' arrow in-arrow';
    },
    computeIdInArrow: function (el, param) {
      return el.element.id + '-' + param + '-arrow';
    },
    computeSelect: function (el) {
      return '#' + el.id;
    },
    computeClassOutArrow: function (el) {
      return el.element.id + ' arrow out-arrow';
    },

    // to do: update style values
    computeCollapseStyle: function (el) {
      return 'top: ' + (el.top + 35) + 'px; left: ' + el.left + 'px; width: 200px; height: 100px';
      //return 'top: ' + (el.top + 35) + 'px; left: ' + el.left + 'px;';//+ ' transform: ' + el.transform + '; width: ' + el.width + 'px; height: ' + el.height + 'px';
    },
    computeIsOpen: function(el) {
      return el.settingOpen===true ? true : false;
    },
    concatClassNames: function() {
      return 'wrapper';//arguments.join(' ');
    },
    _elementsChanged: function() {

    },

    // ===========                  ===================
    //           |*|  ANIMATION  |*|
    // via http://stackoverflow.com/a/19772220/2994108
    animate: function(_fps) {
      var self = this;
      var fps = _fps || 15;
      var fpsInterval = 1000/fps;
      var then = Date.now();
      var startTime = then;
      var elapsed;
      var animationReq;

      self._animationLoop = function(timestamp) {
        now = Date.now();
        elapsed = now - then;
        animationReq = requestAnimationFrame(self._animationLoop);

        if (elapsed > fpsInterval) {
          then = now - (elapsed % fpsInterval);

          self.clock._draw();

          for (var i = 0; i < self._elements.length; i++) {
            if (typeof(self._elements[i].element._draw) !== 'undefined') {
              self._elements[i].element._draw();
            }
          }
        }
      }

      self.cancelAnimation = function() {
        window.cancelAnimationFrame(animationReq);
      }

      self._animationLoop(self._startTime);
    },

    /** Custom Methods **/
    // list public methods in dropdown
    _listPublicMethods: function(el) {
      // var codeEditor = this.$.codeeditor;

      // find this element's public methods
      var publicMethods = el.publicMethods;

      // TO DO: showpublicmethodsinavenue
      if (typeof(publicMethods) !== 'undefined') {
        for (var i = 0; i < publicMethods.length; i++) {

        }
      }
    },

    // show code in the codeEditor
    _showCode: function(el) {
      var self = this;
      var codeEditor = this.$.codeEditor;
      var publicMethods;

      // find this element's public methods
      try {
        publicMethods = el.publicMethods;
      } catch (e) {
        throw 'unable to show code';
        return;
      }

      // this._setupMethodDropdown(this._selElement);

      // for now, just show the first editable method
      // var methodIndex = 0;

      // show code TO DO: make multiple parts editable
      // var displayCode = String(el.publicAudio);

      if (typeof(publicMethods) !== 'undefined' && publicMethods.length > 0) {
        // var methodName = publicMethods[methodIndex];
        var methodName = this._selectedMethod;
        var displayCode;

        // if we have already set a custom value for this method, display that
        if (typeof (this._customMethods[el.id][methodName]) !== 'undefined'){
          displayCode = this._customMethods[el.id][methodName];
        } else {
          displayCode = String(el[methodName]);
          // remove first and last lines of the function to only show its contents
          displayCode = displayCode.split('\n');
          displayCode.shift();
          displayCode.pop();

          // remove indentation so it looks nice
          displayCode.forEach(function(row, index){
            if (row[0] === '\t') {
              // remove the tab
              row = row.substr(1);
            } else if (row[0] === ' ' && row[1] === ' '){
              // remove the space
              row = row.substr(6);
            }
            displayCode[index] = row;
          });

          displayCode = displayCode.join('\n');
        }

        codeEditor.editor.setValue(displayCode);

        // tell codeEditor to update the method when code is changed

        // codeEditor.methodName = methodName;
        // codeEditor.currentMethod = el['methodName'];

        // this.updateCode();

      }
      else {
        codeEditor.setValue('//selected element has no public methods');
        // this.$.methodDropdown.$.label.innerHTML = 'No Method Selected';
        // console.log(this.$.methodDropdown);
        // this.$.methodDropdown.label = 'No Method Selected';

        codeEditor.mirror.on('change', function(e) {

        });
      }

    },

    updateCode: function(x) {

      var codeEditor = this.$.codeEditor;
      var methodName = this._selectedMethod;
      var currentMethod = codeEditor.currentMethod;
      // if there are no errors,

      // set currentMethod
      var newCode = codeEditor.editor.getValue();
      var elMethod = this._selElement[methodName];

      // console.log(this);
      this._selElement[methodName] = Function(newCode).bind(this._selElement);

      this._selElement[methodName]();

      // if (this._autoUpdateCode && (audioContext.currentTime - this._lastCodeUpdate > this._codeUpdateFrequency) ) {
      //   this._selElement[methodName]();
      //   this._codeUpdateFrequency = audioContext.currentTime;
      // }


      this._saveCustomMethod(this._selElement, methodName, newCode );
    },

    // SAVE CUSTOM METHODS

    _initCustomMethodsObj: function(elItem) {
      this._customMethods[elItem.id] = {};
    },

    _saveCustomMethod: function(element, methodName, code) {
      this._customMethods[element.id][methodName] = code;

      // TO DO - ensure that when elements are overwritten,
      // customMethods related to that element are deleted
    },

    _setupMethodDropdown: function(el) {
      var self = this;
      var publicMethods = el.publicMethods;
      this._publicMethods = publicMethods;

      if (typeof(this._publicMethods) !== 'undefined' && this._publicMethods.length > 0) {
        this._selectedMethod = this._publicMethods[0];

        // update paper-menu
        // (this is a hack to get right label to appear)
        setTimeout(function() {
          self.$.selector.select(1);          
        }, 1);
        setTimeout(function() {
          self.$.selector.select(0);          
        }, 2);
      }
    },

    /** custom elements **/

    // convert from an input like olos-element-name-0 to "elementName0"
    _generateVarName: function(elId) {
      // remove split at '-' and remove 'olos' first item from array
      var arr = elId.split('-').slice(1);
      var varName = '';

      varName = arr[0];

      // if varName has additioal stuff, like sound-file, return soundFile
      for (var i = 1; i < arr.length; i++ ) {
        var capString = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
        varName += capString;
      }

      return varName;
    },

    // store element variable name, and include it in olos.elements Array
    _addElementVar: function(elItem) {
      olos[elItem.varName] = elItem.element;
    },

    // OBSERVER for selected element changed
    _selElementChanged: function() {

      // 

      // TO DO: if 'undefined' show global methods
      if (!this._selElement) {
        // this._selElement = this;
        return;
      }

      // TO DO: figure out why this doesnt show as default

      this._selectedMethod = 'No Method Selected';
      this._setupMethodDropdown(this._selElement);
      this._listPublicMethods(this._selElement);
      this._showCode(this._selElement);

      // TO DO: bring back code here
      // this._methodChanged();

      // remove 'selected' class from other elements, add 'selected' class to this
      // this._selElement.className = this._selElement.className + ' selected';

      this._updateDocs(this._selElement);
    },

    /**
     *  update documentation
     */
    _updateDocs: function(element) {
      var pathToHTML = '../../' + element.nodeName.toLowerCase() ;
      this._selElementDocPath = pathToHTML;
    },

    _elInfoButtonClicked: function(e) {
      this.$.infoDialog.toggle()
    },


    // CODE

    // called when the tab to view this element's code is clicked
    _elCodeButtonClicked: function(e) {
      var self = this;
      self.$.codeDialog.toggle();

      // TO DO: figure out why this is necessary
      setTimeout( function() {
        self._showCode(self._selElement);
      }, 400);
    },

    _methodChanged: function(e) {
      var self = this;
      // if (e) {
      //   e.preventDefault();
      //   e.stopPropagation();
      // }
      this._selectedMethod = e.detail.item.label;
      this._showCode(this._selElement);
    }


  });
</script>
